name: Verify Resolution
description: Verify conflict resolution results

inputs:
  resolved-files:
    description: Comma-separated list of resolved files
    required: true
  unresolved-files:
    description: Comma-separated list of unresolved files
    required: true
  no-renames:
    description: Whether no-renames mode was used
    required: false
    default: 'false'

runs:
  using: composite
  steps:
    - name: Print Output
      shell: pwsh
      env:
        RESOLVED_FILES: ${{ inputs.resolved-files }}
        UNRESOLVED_FILES: ${{ inputs.unresolved-files }}
      run: |
        Write-Output "::notice::Resolved files: $env:RESOLVED_FILES"
        Write-Output "::notice::Unresolved files: $env:UNRESOLVED_FILES"

    - name: Verify resolution status
      shell: pwsh
      env:
        RESOLVED_FILES: ${{ inputs.resolved-files }}
        UNRESOLVED_FILES: ${{ inputs.unresolved-files }}
        NO_RENAMES: ${{ inputs.no-renames }}
      run: |
        # Define test file paths for verification
        $TEST_DIR = "__tests__/test-conflict-files"
        $TEST_JSON = "$TEST_DIR/test.json"
        $TEST_MD = "$TEST_DIR/test.md"
        $TEST_CONFIG_YML = "$TEST_DIR/test.config.yml"
        $TEST_TXT = "$TEST_DIR/undefined-rule.txt"
        $TEST_PNG = "$TEST_DIR/test.png"
        $DELETED_BY_US_TXT = "$TEST_DIR/deleted-by-us.txt"
        $DELETED_BY_THEM_TXT = "$TEST_DIR/deleted-by-them.txt"
        $BOTH_ADDED_TXT = "$TEST_DIR/both-added.txt"
        $DELETED_BY_US_PNG = "$TEST_DIR/deleted-by-us.png"
        $DELETED_BY_THEM_PNG = "$TEST_DIR/deleted-by-them.png"
        $BOTH_ADDED_PNG = "$TEST_DIR/both-added.png"
        $RENAME_VS_DELETE_BASE_TXT = "$TEST_DIR/rename-vs-delete-base.txt"
        $RENAME_VS_DELETE_BASE2_TXT = "$TEST_DIR/rename-vs-delete-base-2.txt"

        Write-Output "::group::Verification Results"

        # === Both-Modified conflicts ===
        Write-Output "=== Verifying Both-Modified conflicts ==="

        # Check resolved files (both-modified)
        if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_JSON)) {
          Write-Output "✅ test.json resolved (theirs strategy, both-modified)"
        } else {
          Write-Output "❌ test.json should have been resolved"
          exit 1
        }

        if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_MD)) {
          Write-Output "✅ test.md resolved (ours strategy, both-modified)"
        } else {
          Write-Output "❌ test.md should have been resolved"
          exit 1
        }

        # Check binary files
        if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_PNG)) {
          Write-Output "✅ test.png resolved (theirs strategy, both-modified)"
        } else {
          Write-Output "❌ test.png should have been resolved"
          exit 1
        }

        # === Deleted-By-Us conflicts ===
        Write-Output "`n=== Verifying Deleted-By-Us conflicts ==="

        if ($env:RESOLVED_FILES -match [regex]::Escape($DELETED_BY_US_TXT)) {
          Write-Output "✅ deleted-by-us.txt resolved (theirs strategy, deleted-by-us)"
        } else {
          Write-Output "❌ deleted-by-us.txt should have been resolved"
          exit 1
        }

        if ($env:RESOLVED_FILES -match [regex]::Escape($DELETED_BY_US_PNG)) {
          Write-Output "✅ deleted-by-us.png resolved (theirs strategy, deleted-by-us)"
        } else {
          Write-Output "❌ deleted-by-us.png should have been resolved"
          exit 1
        }

        # === Deleted-By-Them conflicts ===
        Write-Output "`n=== Verifying Deleted-By-Them conflicts ==="

        if ($env:RESOLVED_FILES -match [regex]::Escape($DELETED_BY_THEM_TXT)) {
          Write-Output "✅ deleted-by-them.txt resolved (ours strategy, deleted-by-them)"
        } else {
          Write-Output "❌ deleted-by-them.txt should have been resolved"
          exit 1
        }

        if ($env:RESOLVED_FILES -match [regex]::Escape($DELETED_BY_THEM_PNG)) {
          Write-Output "✅ deleted-by-them.png resolved (ours strategy, deleted-by-them)"
        } else {
          Write-Output "❌ deleted-by-them.png should have been resolved"
          exit 1
        }

        # === Both-Added conflicts ===
        Write-Output "`n=== Verifying Both-Added conflicts ==="

        if ($env:RESOLVED_FILES -match [regex]::Escape($BOTH_ADDED_TXT)) {
          Write-Output "✅ both-added.txt resolved (theirs strategy, both-added)"
        } else {
          Write-Output "❌ both-added.txt should have been resolved"
          exit 1
        }

        if ($env:RESOLVED_FILES -match [regex]::Escape($BOTH_ADDED_PNG)) {
          Write-Output "✅ both-added.png resolved (theirs strategy, both-added)"
        } else {
          Write-Output "❌ both-added.png should have been resolved"
          exit 1
        }

        # === Unresolved files ===
        Write-Output "`n=== Verifying Unresolved files ==="

        # Check unresolved files (manual strategy)
        if ($env:UNRESOLVED_FILES -match [regex]::Escape($TEST_CONFIG_YML)) {
          Write-Output "✅ test.config.yml unresolved (manual strategy)"
        } else {
          Write-Output "❌ test.config.yml should remain unresolved"
          exit 1
        }

        # Check files without rules or with conflict_type mismatch
        if ($env:UNRESOLVED_FILES -match [regex]::Escape($TEST_TXT)) {
          Write-Output "✅ undefined-rule.txt unresolved (has rule with conflict_type mismatch - should be ignored)"
        } else {
          Write-Output "❌ undefined-rule.txt should remain unresolved"
          exit 1
        }

        # Rename vs Delete tests - only run when rename detection is enabled
        if ($env:NO_RENAMES -ne 'true') {
          Write-Output "`n=== Verifying Rename vs Delete conflicts ==="

          # Rename vs Delete (theirs) should be resolved
          if ($env:RESOLVED_FILES -match [regex]::Escape($RENAME_VS_DELETE_BASE_TXT)) {
            Write-Output "✅ rename-vs-delete-base.txt resolved (theirs strategy)"
          } else {
            Write-Output "❌ rename-vs-delete-base.txt should have been resolved"
            exit 1
          }

          if ($env:UNRESOLVED_FILES -match [regex]::Escape($RENAME_VS_DELETE_BASE_TXT)) {
            Write-Output "❌ rename-vs-delete-base.txt should not be unresolved"
            exit 1
          }

          # Rename vs Delete (ours) should be resolved
          if ($env:RESOLVED_FILES -match [regex]::Escape($RENAME_VS_DELETE_BASE2_TXT)) {
            Write-Output "✅ rename-vs-delete-base-2.txt resolved (ours strategy)"
          } else {
            Write-Output "❌ rename-vs-delete-base-2.txt should have been resolved"
            exit 1
          }

          if ($env:UNRESOLVED_FILES -match [regex]::Escape($RENAME_VS_DELETE_BASE2_TXT)) {
            Write-Output "❌ rename-vs-delete-base-2.txt should not be unresolved"
            exit 1
          }

          $renameVsDeleteStatus = git status --porcelain -- $RENAME_VS_DELETE_BASE_TXT
          if ($renameVsDeleteStatus -match "^D") {
            Write-Output "✅ rename-vs-delete-base.txt shows staged deletion (resolved by theirs strategy)"
          } else {
            Write-Output "❌ Expected staged deletion (D) for rename-vs-delete-base.txt after resolving theirs strategy, got: $renameVsDeleteStatus"
            exit 1
          }
        } else {
          Write-Output "`n=== Skipping Rename vs Delete tests (no-renames mode) ==="
          Write-Output "ℹ️ In no-renames mode, rename-vs-delete conflicts are not detected"
        }

        # === Rename/Rename conflicts (DD, AU, UA) - expected to be auto-resolved ===
        # Only run when rename detection is enabled
        if ($env:NO_RENAMES -ne 'true') {
          Write-Output "`n=== Verifying Rename/Rename conflicts are auto-resolved ==="

          $RENAME_TXT = "$TEST_DIR/rename.txt"
          $RENAME_BASE_TXT = "$TEST_DIR/rename-base.txt"
          $RENAME_INCOMING_TXT = "$TEST_DIR/rename-incoming.txt"

          # Expect all rename/rename conflict paths to be resolved
          foreach ($file in @($RENAME_TXT, $RENAME_BASE_TXT, $RENAME_INCOMING_TXT)) {
            if ($env:RESOLVED_FILES -match [regex]::Escape($file)) {
              Write-Output "✅ $file resolved (rename/rename)"
            } else {
              Write-Output "❌ $file should have been resolved (rename/rename)"
              exit 1
            }

            if ($env:UNRESOLVED_FILES -match [regex]::Escape($file)) {
              Write-Output "❌ $file should not be unresolved (rename/rename)"
              exit 1
            }
          }
        } else {
          Write-Output "`n=== Skipping Rename/Rename tests (no-renames mode) ==="
          Write-Output "ℹ️ In no-renames mode, rename/rename conflicts are not detected as such"
        }

        # === Verify conflict_type mismatch behavior ===
        Write-Output "`n=== Verifying conflict_type mismatch behavior ==="

        if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_JSON)) {
          Write-Output "✅ test.json resolved by first matching rule (conflict_type mismatch rule ignored)"
        } else {
          Write-Output "❌ test.json should be resolved by the first matching rule"
          exit 1
        }

        # === Verify rule priority ===
        Write-Output "`n=== Verifying rule priority ==="

        if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_MD)) {
          Write-Output "✅ test.md resolved by first matching rule (later rule ignored)"
        } else {
          Write-Output "❌ test.md should be resolved by the first matching rule"
          exit 1
        }

        Write-Output "::endgroup::"

    - name: Verify resolved file contents
      shell: pwsh
      env:
        NO_RENAMES: ${{ inputs.no-renames }}
      run: |
        # Define test file paths
        $TEST_DIR = "__tests__/test-conflict-files"
        $TEST_JSON = "$TEST_DIR/test.json"
        $TEST_MD = "$TEST_DIR/test.md"
        $TEST_PNG = "$TEST_DIR/test.png"
        $DELETED_BY_US_TXT = "$TEST_DIR/deleted-by-us.txt"
        $DELETED_BY_THEM_TXT = "$TEST_DIR/deleted-by-them.txt"
        $BOTH_ADDED_TXT = "$TEST_DIR/both-added.txt"
        $DELETED_BY_US_PNG = "$TEST_DIR/deleted-by-us.png"
        $DELETED_BY_THEM_PNG = "$TEST_DIR/deleted-by-them.png"
        $BOTH_ADDED_PNG = "$TEST_DIR/both-added.png"
        $RENAME_VS_DELETE_BASE2_TXT = "$TEST_DIR/rename-vs-delete-base-2.txt"
        $RENAME_TXT = "$TEST_DIR/rename.txt"
        $RENAME_BASE_TXT = "$TEST_DIR/rename-base.txt"
        $RENAME_INCOMING_TXT = "$TEST_DIR/rename-incoming.txt"

        Write-Output "::group::Content verification for resolved files"

        # First, check if files exist
        Write-Output "Checking if resolved files exist:"
        Get-ChildItem "$TEST_DIR/"

        Write-Output "`n=== Verifying Both-Modified file contents ==="

        # Verify test.json has incoming changes content (theirs strategy)
        $jsonContent = Get-Content "$TEST_JSON" -Raw
        $expectedJsonContent = Get-Content "$TEST_DIR/incoming-changes/test.json" -Raw
        if ($jsonContent -eq $expectedJsonContent) {
          Write-Output "✅ test.json has correct incoming changes content (theirs)"
        } else {
          Write-Output "❌ test.json does not have expected incoming changes content"
          Write-Output "Actual content:"
          Get-Content "$TEST_JSON"
          Write-Output "Expected content:"
          Get-Content "$TEST_DIR/incoming-changes/test.json"
          exit 1
        }

        # Verify test.md has base version content (ours strategy)
        $mdContent = Get-Content "$TEST_MD" -Raw
        $expectedMdContent = Get-Content "$TEST_DIR/base-version/test.md" -Raw
        if ($mdContent -eq $expectedMdContent) {
          Write-Output "✅ test.md has correct base version content (ours) - first rule takes precedence"
        } else {
          Write-Output "❌ test.md does not have expected base version content"
          Write-Output "Actual content:"
          Get-Content "$TEST_MD"
          Write-Output "Expected content:"
          Get-Content "$TEST_DIR/base-version/test.md"
          exit 1
        }

        # Verify PNG file has incoming changes content (theirs strategy)
        $PNG_SIZE = (Get-Item "$TEST_PNG").Length
        $EXPECTED_SIZE = (Get-Item "$TEST_DIR/incoming-changes/test.png").Length
        Write-Output "PNG file size: $PNG_SIZE bytes"
        if ($PNG_SIZE -eq $EXPECTED_SIZE) {
          Write-Output "✅ test.png has correct incoming changes content ($EXPECTED_SIZE bytes - theirs)"
        } else {
          Write-Output "❌ test.png size: $PNG_SIZE bytes (expected $EXPECTED_SIZE for incoming changes)"
          Get-ChildItem "$TEST_PNG"
          exit 1
        }

        Write-Output "`n=== Verifying Deleted-By-Us file contents ==="

        # Verify deleted-by-us.txt was restored with incoming changes (theirs strategy)
        if (Test-Path $DELETED_BY_US_TXT) {
          $deletedByUsContent = Get-Content "$DELETED_BY_US_TXT" -Raw
          $expectedDeletedByUsContent = Get-Content "$TEST_DIR/incoming-changes/deleted-by-us.txt" -Raw
          if ($deletedByUsContent -eq $expectedDeletedByUsContent) {
            Write-Output "✅ deleted-by-us.txt restored with incoming changes content (theirs)"
          } else {
            Write-Output "❌ deleted-by-us.txt does not have expected incoming changes content"
            exit 1
          }
        } else {
          Write-Output "❌ deleted-by-us.txt should exist (restored by theirs strategy)"
          exit 1
        }

        # Verify deleted-by-us.png was restored with incoming changes (theirs strategy)
        if (Test-Path $DELETED_BY_US_PNG) {
          $deletedByUsPngSize = (Get-Item "$DELETED_BY_US_PNG").Length
          $expectedDeletedByUsPngSize = (Get-Item "$TEST_DIR/incoming-changes/deleted-by-us.png").Length
          if ($deletedByUsPngSize -eq $expectedDeletedByUsPngSize) {
            Write-Output "✅ deleted-by-us.png restored with incoming changes ($expectedDeletedByUsPngSize bytes - theirs)"
          } else {
            Write-Output "❌ deleted-by-us.png size: $deletedByUsPngSize bytes (expected $expectedDeletedByUsPngSize)"
            exit 1
          }
        } else {
          Write-Output "❌ deleted-by-us.png should exist (restored by theirs strategy)"
          exit 1
        }

        Write-Output "`n=== Verifying Deleted-By-Them file contents ==="

        # Verify deleted-by-them.txt kept with our content (ours strategy)
        if (Test-Path $DELETED_BY_THEM_TXT) {
          $deletedByThemContent = Get-Content "$DELETED_BY_THEM_TXT" -Raw
          $expectedDeletedByThemContent = Get-Content "$TEST_DIR/base-version/deleted-by-them.txt" -Raw
          if ($deletedByThemContent -eq $expectedDeletedByThemContent) {
            Write-Output "✅ deleted-by-them.txt kept with base version content (ours)"
          } else {
            Write-Output "❌ deleted-by-them.txt does not have expected base version content"
            exit 1
          }
        } else {
          Write-Output "❌ deleted-by-them.txt should exist (kept by ours strategy)"
          exit 1
        }

        # Verify deleted-by-them.png kept with our content (ours strategy)
        if (Test-Path $DELETED_BY_THEM_PNG) {
          $deletedByThemPngSize = (Get-Item "$DELETED_BY_THEM_PNG").Length
          $expectedDeletedByThemPngSize = (Get-Item "$TEST_DIR/base-version/deleted-by-them.png").Length
          if ($deletedByThemPngSize -eq $expectedDeletedByThemPngSize) {
            Write-Output "✅ deleted-by-them.png kept with base version ($expectedDeletedByThemPngSize bytes - ours)"
          } else {
            Write-Output "❌ deleted-by-them.png size: $deletedByThemPngSize bytes (expected $expectedDeletedByThemPngSize)"
            exit 1
          }
        } else {
          Write-Output "❌ deleted-by-them.png should exist (kept by ours strategy)"
          exit 1
        }

        Write-Output "`n=== Verifying Both-Added file contents ==="

        # Verify both-added.txt has incoming changes content (theirs strategy)
        if (Test-Path $BOTH_ADDED_TXT) {
          $bothAddedContent = Get-Content "$BOTH_ADDED_TXT" -Raw
          $expectedBothAddedContent = Get-Content "$TEST_DIR/incoming-changes/both-added.txt" -Raw
          if ($bothAddedContent -eq $expectedBothAddedContent) {
            Write-Output "✅ both-added.txt has correct incoming changes content (theirs)"
          } else {
            Write-Output "❌ both-added.txt does not have expected incoming changes content"
            exit 1
          }
        } else {
          Write-Output "❌ both-added.txt should exist"
          exit 1
        }

        # Verify both-added.png has incoming changes content (theirs strategy)
        if (Test-Path $BOTH_ADDED_PNG) {
          $bothAddedPngSize = (Get-Item "$BOTH_ADDED_PNG").Length
          $expectedBothAddedPngSize = (Get-Item "$TEST_DIR/incoming-changes/both-added.png").Length

          # Check PNG header to ensure it's a valid PNG file
          $pngBytes = [System.IO.File]::ReadAllBytes($BOTH_ADDED_PNG)
          $expectedHeader = @(137, 80, 78, 71, 13, 10, 26, 10)  # PNG signature
          $isValidPng = $true

          if ($pngBytes.Length -ge 8) {
            for ($i = 0; $i -lt 8; $i++) {
              if ($pngBytes[$i] -ne $expectedHeader[$i]) {
                $isValidPng = $false
                break
              }
            }
          } else {
            $isValidPng = $false
          }

          if (-not $isValidPng) {
            Write-Output "❌ both-added.png is not a valid PNG file after resolution"
            $actualHeader = $pngBytes[0..7] -join ', '
            Write-Output "Expected header: 137, 80, 78, 71, 13, 10, 26, 10"
            Write-Output "Actual header: $actualHeader"
            exit 1
          }

          if ($bothAddedPngSize -eq $expectedBothAddedPngSize) {
            Write-Output "✅ both-added.png has correct incoming changes ($expectedBothAddedPngSize bytes - theirs)"
          } else {
            Write-Output "❌ both-added.png size: $bothAddedPngSize bytes (expected $expectedBothAddedPngSize)"
            exit 1
          }
        } else {
          Write-Output "❌ both-added.png should exist"
          exit 1
        }

        # Verify rename-vs-delete-base-2.txt kept with our content (ours strategy)
        # Only run when rename detection is enabled
        if ($env:NO_RENAMES -ne 'true') {
          if (Test-Path $RENAME_VS_DELETE_BASE2_TXT) {
            $renameVsDeleteOursContent = Get-Content "$RENAME_VS_DELETE_BASE2_TXT" -Raw
            $expectedRenameVsDeleteOursContent = Get-Content "$TEST_DIR/base-version/rename-vs-delete-2.txt" -Raw
            if ($renameVsDeleteOursContent -eq $expectedRenameVsDeleteOursContent) {
              Write-Output "✅ rename-vs-delete-base-2.txt has correct base version content (ours)"
            } else {
              Write-Output "❌ rename-vs-delete-base-2.txt does not have expected base version content"
              exit 1
            }
          } else {
            Write-Output "❌ rename-vs-delete-base-2.txt should exist"
            exit 1
          }
        } else {
          Write-Output "`n=== Skipping rename-vs-delete verification (no-renames mode) ==="
        }

        # === Verify rename/rename resolved state ===
        # Only run when rename detection is enabled
        if ($env:NO_RENAMES -ne 'true') {
          Write-Output "`n=== Verifying rename/rename resolved state ==="

          # Expect ours rename kept
          if (Test-Path $RENAME_BASE_TXT -PathType Leaf) {
            Write-Output "✅ rename-base.txt exists (kept by ours strategy)"
          } else {
            Write-Output "❌ rename-base.txt should exist"
            exit 1
          }

          # Expect theirs rename discarded
          if (-not (Test-Path $RENAME_INCOMING_TXT -PathType Leaf)) {
            Write-Output "✅ rename-incoming.txt does not exist (discarded by ours strategy)"
          } else {
            Write-Output "❌ rename-incoming.txt should not exist"
            exit 1
          }

          # Original path should remain deleted
          if (-not (Test-Path $RENAME_TXT -PathType Leaf)) {
            Write-Output "✅ rename.txt does not exist (kept deleted)"
          } else {
            Write-Output "❌ rename.txt should not exist"
            exit 1
          }
        } else {
          Write-Output "`n=== Skipping rename/rename state verification (no-renames mode) ==="
        }

        Write-Output "::endgroup::"

    - name: Verify unresolved file contents
      shell: pwsh
      env:
        NO_RENAMES: ${{ inputs.no-renames }}
      run: |
        # Define test file paths
        $TEST_DIR = "__tests__/test-conflict-files"
        $TEST_CONFIG_YML = "$TEST_DIR/test.config.yml"
        $TEST_TXT = "$TEST_DIR/undefined-rule.txt"
        $RENAME_VS_DELETE_BASE_TXT = "$TEST_DIR/rename-vs-delete-base.txt"
        $RENAME_VS_DELETE_BASE2_TXT = "$TEST_DIR/rename-vs-delete-base-2.txt"

        Write-Output "::group::Content verification for unresolved files"

        # Check that unresolved files still have conflict markers
        foreach ($file in @($TEST_CONFIG_YML, $TEST_TXT)) {
          if (Test-Path $file -PathType Leaf) {
            $FILE_NAME = Split-Path $file -Leaf
            $content = Get-Content $file -Raw
            if ($content -match "<<<<<<< HEAD" -and
                $content -match "=======" -and
                $content -match ">>>>>>>") {
              Write-Output "✅ $FILE_NAME correctly contains conflict markers"
            } else {
              Write-Output "❌ $FILE_NAME should contain conflict markers but doesn't"
              Write-Output "Actual content:"
              Get-Content $file | Select-Object -First 20
              exit 1
            }
          }
        }

        # Verify specific content in conflict markers
        $configContent = Get-Content $TEST_CONFIG_YML -Raw
        if ($configContent -match "name: base-app" -and
            $configContent -match "name: incoming-app") {
          Write-Output "✅ test.config.yml contains both versions' contents in conflict"
        } else {
          Write-Output "❌ test.config.yml missing expected conflict content"
          exit 1
        }

        # rename-vs-delete verification - only run when rename detection is enabled
        if ($env:NO_RENAMES -ne 'true') {
          # rename-vs-delete-base.txt should NOT exist (theirs resolution stages deletion)
          if (-not (Test-Path $RENAME_VS_DELETE_BASE_TXT -PathType Leaf)) {
            Write-Output "✅ rename-vs-delete-base.txt does not exist (staged deletion)"
          } else {
            Write-Output "❌ rename-vs-delete-base.txt should not exist"
            exit 1
          }

          # rename-vs-delete-base-2.txt should exist (ours strategy)
          if (Test-Path $RENAME_VS_DELETE_BASE2_TXT -PathType Leaf) {
            Write-Output "✅ rename-vs-delete-base-2.txt exists (ours strategy)"
          } else {
            Write-Output "❌ rename-vs-delete-base-2.txt should exist"
            exit 1
          }
        } else {
          Write-Output "ℹ️ Skipping rename-vs-delete file existence checks (no-renames mode)"
        }

        Write-Output "::endgroup::"
