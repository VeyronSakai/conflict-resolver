name: Continuous Integration

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

permissions:
  contents: read

jobs:
  test-typescript:
    name: TypeScript Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v5
        with:
          persist-credentials: false

      - name: Setup Node.js
        id: setup-node
        uses: actions/setup-node@v5
        with:
          node-version-file: .node-version
          cache: npm

      - name: Install Dependencies
        id: npm-ci
        run: npm ci

      - name: Check Format
        id: npm-format-check
        run: npm run format:check

      - name: Lint
        id: npm-lint
        run: npm run lint

      - name: Test
        id: npm-ci-test
        run: npm run ci-test

  test-action:
    name: GitHub Actions Test
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Git
        shell: pwsh
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      - name: Create test branches and conflicts
        id: create-conflicts
        shell: pwsh
        env:
          RUN_ID: ${{ github.run_id }}
        run: |
          # Define test directory
          $TEST_DIR = "__tests__/test-conflict-files"

          # Create base branch with test files
          git switch -C "test-base-$env:RUN_ID"

          # Create incoming changes branch
          git switch -C "test-incoming-$env:RUN_ID"

          # Copy incoming changes files
          Copy-Item "$TEST_DIR/incoming-changes/*" "$TEST_DIR/" -Force

          git add "$TEST_DIR/"
          git commit -m "Incoming changes"

          # Create current branch with base version changes
          git switch "test-base-$env:RUN_ID"
          git switch -C "test-current-$env:RUN_ID"

          # Copy base version files
          Copy-Item "$TEST_DIR/base-version/*" "$TEST_DIR/" -Force

          git add "$TEST_DIR/"
          git commit -m "Base version changes"

          # Attempt to merge incoming changes into current branch to create conflicts
          Write-Output "::notice::Attempting to merge incoming changes into current branch..."
          try { 
            git merge "test-incoming-$env:RUN_ID" --no-ff --no-commit
          } catch { 
            # Merge conflict is expected
          }

          # Check conflict status
          Write-Output "::group::Git status after merge attempt"
          git status
          Write-Output "::endgroup::"

          Write-Output "::group::Conflicted files"
          $conflicted = git status --porcelain | Select-String "^UU"
          if ($conflicted) {
            $conflicted
          } else {
            Write-Output "No conflicts found"
          }
          Write-Output "::endgroup::"

          # Save conflict state
          if (git status --porcelain | Select-String -Quiet "^UU") {
            "has_conflicts=true" | Out-File -Append $env:GITHUB_OUTPUT
            Write-Output "::notice::Conflicts detected. Ready to test conflict resolver."
          } else {
            "has_conflicts=false" | Out-File -Append $env:GITHUB_OUTPUT
            Write-Output "::warning::No conflicts detected."
          }

      - name: Test Local Action
        id: test-action
        uses: ./
        with:
          config-path: "__tests__/conflict-resolver-test.yml"

      - name: Print Output
        id: output
        shell: pwsh
        env:
          RESOLVED_FILES: ${{ steps.test-action.outputs.resolved-files }}
          UNRESOLVED_FILES: ${{ steps.test-action.outputs.unresolved-files }}
        run: |
          Write-Output "::notice::Resolved files: $env:RESOLVED_FILES"
          Write-Output "::notice::Unresolved files: $env:UNRESOLVED_FILES"

      - name: Verify resolution status
        shell: pwsh
        env:
          RESOLVED_FILES: ${{ steps.test-action.outputs.resolved-files }}
          UNRESOLVED_FILES: ${{ steps.test-action.outputs.unresolved-files }}
        run: |
          # Define test file paths for verification
          $TEST_DIR = "__tests__/test-conflict-files"
          $TEST_JSON = "$TEST_DIR/test.json"
          $TEST_MD = "$TEST_DIR/test.md"
          $TEST_CONFIG_YML = "$TEST_DIR/test.config.yml"
          $TEST_TXT = "$TEST_DIR/undefined-rule.txt"
          $TEST_PNG = "$TEST_DIR/test.png"

          Write-Output "::group::Verification Results"

          # Check resolved files
          if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_JSON)) {
            Write-Output "✅ test.json resolved (theirs strategy)"
          } else {
            Write-Output "❌ test.json should have been resolved"
            exit 1
          }

          if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_MD)) {
            Write-Output "✅ test.md resolved (ours strategy)"
          } else {
            Write-Output "❌ test.md should have been resolved"
            exit 1
          }

          # Check binary files
          if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_PNG)) {
            Write-Output "✅ test.png resolved (theirs strategy)"
          } else {
            Write-Output "❌ test.png should have been resolved"
            exit 1
          }

          # Check unresolved files (manual strategy)
          if ($env:UNRESOLVED_FILES -match [regex]::Escape($TEST_CONFIG_YML)) {
            Write-Output "✅ test.config.yml unresolved (manual strategy)"
          } else {
            Write-Output "❌ test.config.yml should remain unresolved"
            exit 1
          }

          # Check files without rules
          if ($env:UNRESOLVED_FILES -match [regex]::Escape($TEST_TXT)) {
            Write-Output "✅ undefined-rule.txt unresolved (no rule defined)"
          } else {
            Write-Output "❌ undefined-rule.txt should remain unresolved"
            exit 1
          }

          Write-Output "::endgroup::"

      - name: Verify resolved file contents
        shell: pwsh
        run: |
          # Define test file paths
          $TEST_DIR = "__tests__/test-conflict-files"
          $TEST_JSON = "$TEST_DIR/test.json"
          $TEST_MD = "$TEST_DIR/test.md"
          $TEST_PNG = "$TEST_DIR/test.png"

          Write-Output "::group::Content verification for resolved files"

          # First, check if files exist
          Write-Output "Checking if resolved files exist:"
          Get-ChildItem "$TEST_DIR/"

          # Verify test.json has incoming changes content (theirs strategy)
          $jsonContent = Get-Content "$TEST_JSON" -Raw
          $expectedJsonContent = Get-Content "$TEST_DIR/incoming-changes/test.json" -Raw
          if ($jsonContent -eq $expectedJsonContent) {
            Write-Output "✅ test.json has correct incoming changes content (theirs)"
          } else {
            Write-Output "❌ test.json does not have expected incoming changes content"
            Write-Output "Actual content:"
            Get-Content "$TEST_JSON"
            Write-Output "Expected content:"
            Get-Content "$TEST_DIR/incoming-changes/test.json"
            exit 1
          }

          # Verify test.md has base version content (ours strategy)
          $mdContent = Get-Content "$TEST_MD" -Raw
          $expectedMdContent = Get-Content "$TEST_DIR/base-version/test.md" -Raw
          if ($mdContent -eq $expectedMdContent) {
            Write-Output "✅ test.md has correct base version content (ours)"
          } else {
            Write-Output "❌ test.md does not have expected base version content"
            Write-Output "Actual content:"
            Get-Content "$TEST_MD"
            Write-Output "Expected content:"
            Get-Content "$TEST_DIR/base-version/test.md"
            exit 1
          }

          # Verify PNG file has incoming changes content (theirs strategy)
          $PNG_SIZE = (Get-Item "$TEST_PNG").Length
          $EXPECTED_SIZE = (Get-Item "$TEST_DIR/incoming-changes/test.png").Length
          Write-Output "PNG file size: $PNG_SIZE bytes"
          if ($PNG_SIZE -eq $EXPECTED_SIZE) {
            Write-Output "✅ test.png has correct incoming changes content ($EXPECTED_SIZE bytes - theirs)"
          } else {
            Write-Output "❌ test.png size: $PNG_SIZE bytes (expected $EXPECTED_SIZE for incoming changes)"
            Get-ChildItem "$TEST_PNG"
            exit 1
          }

          Write-Output "::endgroup::"

      - name: Verify unresolved file contents
        shell: pwsh
        run: |
          # Define test file paths
          $TEST_DIR = "__tests__/test-conflict-files"
          $TEST_CONFIG_YML = "$TEST_DIR/test.config.yml"
          $TEST_TXT = "$TEST_DIR/undefined-rule.txt"

          Write-Output "::group::Content verification for unresolved files"

          # Check that unresolved files still have conflict markers
          foreach ($file in @($TEST_CONFIG_YML, $TEST_TXT)) {
            if (Test-Path $file -PathType Leaf) {
              $FILE_NAME = Split-Path $file -Leaf
              $content = Get-Content $file -Raw
              if ($content -match "<<<<<<< HEAD" -and
                  $content -match "=======" -and
                  $content -match ">>>>>>>") {
                Write-Output "✅ $FILE_NAME correctly contains conflict markers"
              } else {
                Write-Output "❌ $FILE_NAME should contain conflict markers but doesn't"
                Write-Output "Actual content:"
                Get-Content $file | Select-Object -First 20
                exit 1
              }
            }
          }

          # Verify specific content in conflict markers
          $configContent = Get-Content $TEST_CONFIG_YML -Raw
          if ($configContent -match "name: base-app" -and
              $configContent -match "name: incoming-app") {
            Write-Output "✅ test.config.yml contains both versions' contents in conflict"
          } else {
            Write-Output "❌ test.config.yml missing expected conflict content"
            exit 1
          }

          Write-Output "::endgroup::"

