name: Continuous Integration

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

permissions:
  contents: read

jobs:
  test-typescript:
    name: TypeScript Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v5
        with:
          persist-credentials: false

      - name: Setup Node.js
        id: setup-node
        uses: actions/setup-node@v5
        with:
          node-version-file: .node-version
          cache: npm

      - name: Install Dependencies
        id: npm-ci
        run: npm ci

      - name: Check Format
        id: npm-format-check
        run: npm run format:check

      - name: Lint
        id: npm-lint
        run: npm run lint

      - name: Test
        id: npm-ci-test
        run: npm run ci-test

  test-action:
    name: GitHub Actions Test
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      - name: Create test branches and conflicts
        id: create-conflicts
        run: |
          # Save current branch (not used, kept for reference)
          # ORIGINAL_BRANCH=$(git branch --show-current)

          # Define test file paths
          TEST_DIR="__tests__/test-conflict-files"
          TEST_JSON="$TEST_DIR/test.json"
          TEST_MD="$TEST_DIR/test.md"
          TEST_TS="$TEST_DIR/test.ts"
          TEST_CONFIG_YML="$TEST_DIR/test.config.yml"
          TEST_CRITICAL_TS="$TEST_DIR/critical.ts"
          TEST_TXT="$TEST_DIR/undefined-rule.txt"
          TEST_XML="$TEST_DIR/special-case.xml"
          TEST_PNG="$TEST_DIR/test.png"
          TEST_PDF="$TEST_DIR/test.pdf"
          TEST_ZIP="$TEST_DIR/test.zip"
          TEST_TEMP="$TEST_DIR/temp.txt"

          # Create base branch with test files
          git checkout -b test-base-${{ github.run_id }}

          # The test files are already in the repository
          git add "$TEST_DIR/"
          git commit -m "Add base test files" || echo "Files already committed"

          # Create branch 1 with changes
          git checkout -b test-branch-1-${{ github.run_id }}

          # Modify text files in branch 1
          cat > "$TEST_JSON" << 'EOF'
          {
            "version": "1.1.0",
            "name": "branch-1-test",
            "description": "Branch 1 JSON content with changes",
            "config": {
              "enabled": false,
              "mode": "production",
              "newField": "branch1-specific"
            }
          }
          EOF

          cat > "$TEST_MD" << 'EOF'
          # Branch 1 Documentation

          This is the branch 1 version of the documentation.

          ## Section 1
          Branch 1 has completely different content here.

          ## Section 2
          Branch 1 removed the original section 2.

          ## Section 3
          New section added only in branch 1.
          EOF

          cat > "$TEST_TS" << 'EOF'
          export function branch1Function(): string {
            console.log('Branch 1 version');
            return 'branch1';
          }

          export class Branch1Class {
            private value: string;

            constructor() {
              this.value = 'branch1';
            }

            getValue(): string {
              return this.value;
            }
            
            branch1Method(): void {
              console.log('Branch 1 specific method');
            }
          }
          EOF

          cat > "$TEST_CONFIG_YML" << 'EOF'
          # Configuration file - Branch 1 version
          application:
            name: branch1-app
            version: 1.1.0
            
          settings:
            debug: true
            timeout: 60
            branch1_setting: enabled
            
          database:
            host: branch1.db.com
            port: 3306
          EOF

          cat > "$TEST_CRITICAL_TS" << 'EOF'
          // Critical file - Branch 1 version
          export class CriticalService {
            private apiKey: string;
            private endpoint: string;

            constructor() {
              this.apiKey = 'branch1-key-xyz';
              this.endpoint = 'https://api.branch1.com';
            }

            async performCriticalOperation(): Promise<void> {
              // Branch 1 implementation
              console.log('Branch 1 critical operation');
              await this.validateBranch1();
            }
            
            private async validateBranch1(): Promise<void> {
              // Branch 1 specific validation
            }
          }
          EOF

          cat > "$TEST_TXT" << 'EOF'
          This is branch 1 version of the text file.
          No resolution rule is defined for this file.

          Branch 1 content:
          - Feature A
          - Feature B
          - Feature C

          Branch 1 end.
          EOF

          cat > "$TEST_XML" << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <configuration>
            <settings>
              <property name="version">1.1.0</property>
              <property name="mode">branch1</property>
              <property name="branch1">true</property>
            </settings>
            <data>
              <item id="1">Branch 1 Item 1</item>
              <item id="2">Branch 1 Item 2</item>
              <item id="3">Branch 1 New Item</item>
            </data>
          </configuration>
          EOF

          # Create different binary files for branch 1
          # PNG file (2x2 pixels)
          {
            printf '\x89PNG\r\n\x1a\n'
            printf '\x00\x00\x00\rIHDR\x00\x00\x00\x02\x00\x00\x00\x02'
            printf '\x08\x02\x00\x00\x00\xfd\xd4\x9as'
            printf '\x00\x00\x00\x0cIDATx\x9cc\xf8\x0f\x00\x00\x01\x01\x00\x05'
            printf '\x00\x00\x00\x00IEND\xaeB`\x82'
          } > "$TEST_PNG"

          # PDF file
          {
            printf '%%PDF-1.4\n%%Branch1\n'
            printf '1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n'
            printf '2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n'
            printf '3 0 obj\n<< /Type /Page /Parent 2 0 R '
            printf '/Resources << >> /MediaBox [0 0 612 792] >>\nendobj\n'
            printf 'xref\n0 4\n0000000000 65535 f\n'
            printf '0000000009 00000 n\n0000000058 00000 n\n'
            printf '0000000115 00000 n\ntrailer\n'
            printf '<< /Size 4 /Root 1 0 R >>\nstartxref\n203\n%%%%EOF'
          } > "$TEST_PDF"

          echo "Branch 1 content for ZIP" > "$TEST_TEMP"
          (cd "$TEST_DIR" && zip -q "${TEST_ZIP##*/}" "${TEST_TEMP##*/}" && rm "${TEST_TEMP##*/}")

          git add "$TEST_DIR/"
          git commit -m "Branch 1 changes"

          # Create branch 2 with different changes
          git checkout test-base-${{ github.run_id }}
          git checkout -b test-branch-2-${{ github.run_id }}

          # Modify files differently in branch 2
          cat > "$TEST_JSON" << 'EOF'
          {
            "version": "1.2.0",
            "name": "branch-2-test",
            "description": "Branch 2 JSON with different changes",
            "config": {
              "enabled": true,
              "mode": "development",
              "differentField": "branch2-specific"
            }
          }
          EOF

          cat > "$TEST_MD" << 'EOF'
          # Branch 2 Documentation

          This is the branch 2 version of the documentation.

          ## Section 1
          Branch 2 has its own content for section 1.

          ## Section 2
          Branch 2 kept section 2 but changed it.

          ### Subsection 2.1
          Branch 2 modified subsection.

          ## Section 4
          Branch 2 added section 4 instead of 3.
          EOF

          cat > "$TEST_TS" << 'EOF'
          export function branch2Function(): string {
            console.log('Branch 2 version');
            return 'branch2';
          }

          export class Branch2Class {
            private value: string;

            constructor() {
              this.value = 'branch2';
            }

            getValue(): string {
              return this.value;
            }
            
            branch2Method(): void {
              console.log('Branch 2 specific method');
            }
          }
          EOF

          cat > "$TEST_CONFIG_YML" << 'EOF'
          # Configuration file - Branch 2 version
          application:
            name: branch2-app
            version: 1.2.0
            
          settings:
            debug: false
            timeout: 90
            branch2_setting: active
            
          database:
            host: branch2.db.com
            port: 5432
            replica: true
          EOF

          cat > "$TEST_CRITICAL_TS" << 'EOF'
          // Critical file - Branch 2 version
          export class CriticalService {
            private apiKey: string;
            private endpoint: string;
            private region: string;

            constructor() {
              this.apiKey = 'branch2-key-abc';
              this.endpoint = 'https://api.branch2.com';
              this.region = 'us-west';
            }

            async performCriticalOperation(): Promise<void> {
              // Branch 2 implementation
              console.log('Branch 2 critical operation');
              await this.validateBranch2();
            }
            
            private async validateBranch2(): Promise<void> {
              // Branch 2 specific validation
            }
          }
          EOF

          cat > "$TEST_TXT" << 'EOF'
          This is branch 2 version of the text file.
          No resolution rule is defined for this file.

          Branch 2 content:
          - Feature X
          - Feature Y
          - Feature Z

          Branch 2 end.
          EOF

          cat > "$TEST_XML" << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <configuration>
            <settings>
              <property name="version">1.2.0</property>
              <property name="mode">branch2</property>
              <property name="branch2">true</property>
            </settings>
            <data>
              <item id="1">Branch 2 Item 1</item>
              <item id="2">Branch 2 Item 2</item>
              <item id="4">Branch 2 Different Item</item>
            </data>
          </configuration>
          EOF

          # Create different binary files for branch 2
          # PNG file (3x3 pixels)
          {
            printf '\x89PNG\r\n\x1a\n'
            printf '\x00\x00\x00\rIHDR\x00\x00\x00\x03\x00\x00\x00\x03'
            printf '\x08\x02\x00\x00\x00\xd9J"\xe8'
            printf '\x00\x00\x00\x0cIDATx\x9cc\xf8\x0f\x00\x00\x01\x01\x00\x05'
            printf '\x00\x00\x00\x00IEND\xaeB`\x82'
          } > "$TEST_PNG"

          # PDF file
          {
            printf '%%PDF-1.4\n%%Branch2\n'
            printf '1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n'
            printf '2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 2 >>\nendobj\n'
            printf '3 0 obj\n<< /Type /Page /Parent 2 0 R '
            printf '/Resources << >> /MediaBox [0 0 612 792] >>\nendobj\n'
            printf 'xref\n0 4\n0000000000 65535 f\n'
            printf '0000000009 00000 n\n0000000058 00000 n\n'
            printf '0000000115 00000 n\ntrailer\n'
            printf '<< /Size 4 /Root 1 0 R >>\nstartxref\n203\n%%%%EOF'
          } > "$TEST_PDF"

          echo "Branch 2 content for ZIP" > "$TEST_TEMP"
          (cd "$TEST_DIR" && zip -q "${TEST_ZIP##*/}" "${TEST_TEMP##*/}" && rm "${TEST_TEMP##*/}")

          git add "$TEST_DIR/"
          git commit -m "Branch 2 changes"

          # Attempt to merge branch 1 into branch 2 to create conflicts
          echo "::notice::Attempting to merge branch-1 into branch-2..."
          git merge test-branch-1-${{ github.run_id }} --no-ff --no-commit || true

          # Check conflict status
          echo "::group::Git status after merge attempt"
          git status
          echo "::endgroup::"

          echo "::group::Conflicted files"
          git status --porcelain | grep "^UU" || echo "No conflicts found"
          echo "::endgroup::"

          # Save conflict state
          if git status --porcelain | grep -q "^UU"; then
            echo "has_conflicts=true" >> "$GITHUB_OUTPUT"
            echo "::notice::Conflicts detected. Ready to test conflict resolver."
          else
            echo "has_conflicts=false" >> "$GITHUB_OUTPUT"
            echo "::warning::No conflicts detected."
          fi

      - name: Show conflict details
        if: steps.create-conflicts.outputs.has_conflicts == 'true'
        run: |
          echo "::group::List of conflicted files"
          git diff --name-only --diff-filter=U
          echo "::endgroup::"

          for file in "$TEST_DIR"/*.{json,md,ts,yml,txt,xml}; do
            if [ -f "$file" ] && \
               git diff --check "$file" 2>/dev/null | grep -q "conflict"; then
              echo "::group::Conflict in $file"
              cat "$file" | head -50
              echo "::endgroup::"
            fi
          done

      - name: Test Local Action
        id: test-action
        uses: ./
        with:
          config-path: "__tests__/conflict-resolver-test.yml"

      - name: Print Output
        id: output
        env:
          RESOLVED_FILES: ${{ steps.test-action.outputs.resolved-files }}
          UNRESOLVED_FILES: ${{ steps.test-action.outputs.unresolved-files }}
        run: |
          echo "::notice::Resolved files: $RESOLVED_FILES"
          echo "::notice::Unresolved files: $UNRESOLVED_FILES"

          # Define test file paths for verification
          TEST_DIR="__tests__/test-conflict-files"
          TEST_JSON="$TEST_DIR/test.json"
          TEST_MD="$TEST_DIR/test.md"
          TEST_TS="$TEST_DIR/test.ts"
          TEST_CONFIG_YML="$TEST_DIR/test.config.yml"
          TEST_CRITICAL_TS="$TEST_DIR/critical.ts"
          TEST_TXT="$TEST_DIR/undefined-rule.txt"
          TEST_XML="$TEST_DIR/special-case.xml"
          TEST_PNG="$TEST_DIR/test.png"
          TEST_PDF="$TEST_DIR/test.pdf"
          TEST_ZIP="$TEST_DIR/test.zip"

          # Verify expected outcomes
          echo "::group::Verification Results"

          # Check resolved files
          if echo "$RESOLVED_FILES" | grep -q "$TEST_JSON"; then
            echo "✅ test.json resolved (theirs strategy)"
          else
            echo "❌ test.json should have been resolved"
          fi

          if echo "$RESOLVED_FILES" | grep -q "$TEST_MD"; then
            echo "✅ test.md resolved (ours strategy)"
          else
            echo "❌ test.md should have been resolved"
          fi

          if echo "$RESOLVED_FILES" | grep -q "$TEST_TS"; then
            echo "✅ test.ts resolved (theirs strategy)"
          else
            echo "❌ test.ts should have been resolved"
          fi

          # Check binary files
          if echo "$RESOLVED_FILES" | grep -q "$TEST_PNG"; then
            echo "✅ test.png resolved (theirs strategy)"
          else
            echo "❌ test.png should have been resolved"
          fi

          if echo "$RESOLVED_FILES" | grep -q "$TEST_PDF"; then
            echo "✅ test.pdf resolved (ours strategy)"
          else
            echo "❌ test.pdf should have been resolved"
          fi

          if echo "$RESOLVED_FILES" | grep -q "$TEST_ZIP"; then
            echo "✅ test.zip resolved (theirs strategy)"
          else
            echo "❌ test.zip should have been resolved"
          fi

          # Check unresolved files (manual strategy)
          if echo "$UNRESOLVED_FILES" | grep -q "$TEST_CONFIG_YML"; then
            echo "✅ test.config.yml unresolved (manual strategy)"
          else
            echo "❌ test.config.yml should remain unresolved"
          fi

          if echo "$UNRESOLVED_FILES" | grep -q "$TEST_CRITICAL_TS"; then
            echo "✅ critical.ts unresolved (manual strategy)"
          else
            echo "❌ critical.ts should remain unresolved"
          fi

          # Check files without rules
          if echo "$UNRESOLVED_FILES" | grep -q "$TEST_TXT"; then
            echo "✅ undefined-rule.txt unresolved (no rule defined)"
          else
            echo "❌ undefined-rule.txt should remain unresolved"
          fi

          if echo "$UNRESOLVED_FILES" | grep -q "$TEST_XML"; then
            echo "✅ special-case.xml unresolved (no rule defined)"
          else
            echo "❌ special-case.xml should remain unresolved"
          fi

          echo "::endgroup::"

      - name: Verify resolved file contents
        run: |
          set -x  # Enable debug output
          # Define test file paths
          TEST_DIR="__tests__/test-conflict-files"
          TEST_JSON="$TEST_DIR/test.json"
          TEST_MD="$TEST_DIR/test.md"
          TEST_TS="$TEST_DIR/test.ts"
          TEST_PNG="$TEST_DIR/test.png"
          TEST_PDF="$TEST_DIR/test.pdf"
          TEST_ZIP="$TEST_DIR/test.zip"

          echo "::group::Content verification for resolved files"

          # First, check if files exist
          echo "Checking if resolved files exist:"
          ls -la "$TEST_DIR/"

          # Verify test.json has branch-1 content (theirs strategy)
          if grep -q '"version": "1.1.0"' "$TEST_JSON" && \
             grep -q '"name": "branch-1-test"' "$TEST_JSON" && \
             grep -q '"newField": "branch1-specific"' "$TEST_JSON"; then
            echo "✅ test.json has correct branch-1 content (theirs)"
          else
            echo "❌ test.json does not have expected branch-1 content"
            echo "Actual content:"
            cat "$TEST_JSON"
            exit 1
          fi

          # Verify test.md has branch-2 content (ours strategy)
          if grep -q "# Branch 2 Documentation" "$TEST_MD" && \
             grep -q "Branch 2 has its own content for section 1" "$TEST_MD" && \
             grep -q "## Section 4" "$TEST_MD"; then
            echo "✅ test.md has correct branch-2 content (ours)"
          else
            echo "❌ test.md does not have expected branch-2 content"
            echo "Actual content:"
            cat "$TEST_MD"
            exit 1
          fi

          # Verify test.ts has branch-1 content (theirs strategy)
          if grep -q "branch1Function" "$TEST_TS" && \
             grep -q "Branch1Class" "$TEST_TS" && \
             grep -q "branch1Method" "$TEST_TS"; then
            echo "✅ test.ts has correct branch-1 content (theirs)"
          else
            echo "❌ test.ts does not have expected branch-1 content"
            echo "Actual content:"
            cat "$TEST_TS"
            exit 1
          fi

          # Verify PNG file has branch-1 content (theirs strategy - 2x2 pixels)
          PNG_SIZE=$(stat -c%s "$TEST_PNG" 2>/dev/null || stat -f%z "$TEST_PNG" 2>/dev/null || wc -c < "$TEST_PNG")
          # Remove any whitespace from the size
          PNG_SIZE=$(echo "$PNG_SIZE" | tr -d ' ')
          echo "PNG file size: $PNG_SIZE bytes"
          if [ "$PNG_SIZE" -eq 57 ]; then
            echo "✅ test.png has correct branch-1 content (2x2 pixels, 57 bytes)"
          elif [ "$PNG_SIZE" -eq 61 ]; then
            echo "❌ test.png has branch-2 content (3x3 pixels, 61 bytes) instead of branch-1"
            exit 1
          else
            echo "❌ test.png size: $PNG_SIZE bytes (expected 57 for branch-1)"
            ls -la "$TEST_PNG"
            exit 1
          fi

          # Verify PDF file has branch-2 content (ours strategy)
          echo "Checking PDF content:"
          head -2 "$TEST_PDF" | od -c
          if grep -q "%%Branch2" "$TEST_PDF" && \
             grep -q "/Count 2" "$TEST_PDF"; then
            echo "✅ test.pdf has correct branch-2 content (ours)"
          elif grep -q "%%Branch1" "$TEST_PDF"; then
            echo "❌ test.pdf has branch-1 content instead of branch-2"
            exit 1
          else
            echo "❌ test.pdf does not have expected branch-2 content"
            echo "Actual PDF header:"
            head -5 "$TEST_PDF"
            exit 1
          fi

          # Verify ZIP file has branch-1 content (theirs strategy)
          # Use Python to verify ZIP content (always available in GitHub Actions)
          echo "Verifying ZIP content..."
          python3 -c "
import zipfile
import sys
try:
    with zipfile.ZipFile('$TEST_ZIP', 'r') as z:
        content = z.read('temp.txt').decode('utf-8')
        if 'Branch 1 content for ZIP' in content:
            print('✅ test.zip has correct branch-1 content (theirs)')
            sys.exit(0)
        else:
            print('❌ test.zip does not have expected branch-1 content')
            print('Actual content:', content)
            sys.exit(1)
except Exception as e:
    print(f'❌ Failed to read ZIP file: {e}')
    sys.exit(1)
"

          echo "::endgroup::"

      - name: Verify unresolved file contents
        run: |
          set -x  # Enable debug output
          # Define test file paths
          TEST_DIR="__tests__/test-conflict-files"
          TEST_CONFIG_YML="$TEST_DIR/test.config.yml"
          TEST_CRITICAL_TS="$TEST_DIR/critical.ts"
          TEST_TXT="$TEST_DIR/undefined-rule.txt"
          TEST_XML="$TEST_DIR/special-case.xml"

          echo "::group::Content verification for unresolved files"

          # Check that unresolved files still have conflict markers
          for file in "$TEST_CONFIG_YML" "$TEST_CRITICAL_TS" "$TEST_TXT" "$TEST_XML"; do
            if [ -f "$file" ]; then
              FILE_NAME=$(basename "$file")
              if grep -q "<<<<<<< HEAD" "$file" && \
                 grep -q "=======" "$file" && \
                 grep -q ">>>>>>>" "$file"; then
                echo "✅ $FILE_NAME correctly contains conflict markers"
              else
                echo "❌ $FILE_NAME should contain conflict markers but doesn't"
                echo "Actual content:"
                head -20 "$file"
                exit 1
              fi
            fi
          done

          # Verify specific content in conflict markers
          if grep -q "name: branch2-app" "$TEST_CONFIG_YML" && \
             grep -q "name: branch1-app" "$TEST_CONFIG_YML"; then
            echo "✅ test.config.yml contains both branch contents in conflict"
          else
            echo "❌ test.config.yml missing expected conflict content"
            exit 1
          fi

          if grep -q "branch1-key-xyz" "$TEST_CRITICAL_TS" && \
             grep -q "branch2-key-abc" "$TEST_CRITICAL_TS"; then
            echo "✅ critical.ts contains both branch API keys in conflict"
          else
            echo "❌ critical.ts missing expected conflict content"
            exit 1
          fi

          echo "::endgroup::"

      - name: Show final file contents
        run: |
          # Define test file paths
          TEST_DIR="__tests__/test-conflict-files"
          TEST_JSON="$TEST_DIR/test.json"
          TEST_MD="$TEST_DIR/test.md"

          echo "::group::Final resolved file contents (samples)"

          echo "--- test.json (should have branch-1 content - theirs) ---"
          cat "$TEST_JSON" | head -10

          echo ""
          echo "--- test.md (should have branch-2 content - ours) ---"
          cat "$TEST_MD" | head -10

          echo "::endgroup::"

          echo "::group::Unresolved files with conflict markers"

          for file in "$TEST_CONFIG_YML" \
                      "$TEST_CRITICAL_TS" \
                      "$TEST_TXT" \
                      "$TEST_XML"; do
            if [ -f "$file" ]; then
              echo "--- $file ---"
              grep -E "^(<<<<<<<|=======|>>>>>>>)" "$file" || \
                echo "No conflict markers found (might be an error)"
              echo ""
            fi
          done

          echo "::endgroup::"
