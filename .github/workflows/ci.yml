---
name: Continuous Integration

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

permissions:
  contents: read

jobs:
  test-typescript:
    name: TypeScript Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v5
        with:
          persist-credentials: false

      - name: Setup Node.js
        id: setup-node
        uses: actions/setup-node@v5
        with:
          node-version-file: .node-version
          cache: npm

      - name: Install Dependencies
        id: npm-ci
        run: npm ci

      - name: Check Format
        id: npm-format-check
        run: npm run format:check

      - name: Lint
        id: npm-lint
        run: npm run lint

      - name: Test
        id: npm-ci-test
        run: npm run ci-test

  test-action:
    name: GitHub Actions Test
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      - name: Create test branches and conflicts
        id: create-conflicts
        shell: pwsh
        run: |
          # Define test file paths
          $TEST_DIR = "test-conflict-files"
          $TEST_JSON = "$TEST_DIR/test.json"
          $TEST_MD = "$TEST_DIR/test.md"
          $TEST_TS = "$TEST_DIR/test.ts"
          $TEST_CONFIG_YML = "$TEST_DIR/test.config.yml"
          $TEST_CRITICAL_TS = "$TEST_DIR/critical.ts"
          $TEST_TXT = "$TEST_DIR/undefined-rule.txt"
          $TEST_XML = "$TEST_DIR/special-case.xml"
          $TEST_PNG = "$TEST_DIR/test.png"
          $TEST_PDF = "$TEST_DIR/test.pdf"
          $TEST_ZIP = "$TEST_DIR/test.zip"
          $TEST_TEMP = "$TEST_DIR/temp.txt"

          # Create base branch with test files
          git checkout -b test-base-${{ github.run_id }}

          # The test files are already in the repository
          git add "$TEST_DIR/"
          try { git commit -m "Add base test files" } catch { Write-Output "Files already committed" }

          # Create branch 1 with changes
          git checkout -b test-branch-1-${{ github.run_id }}

          # Modify text files in branch 1
          @'
          {
            "version": "1.1.0",
            "name": "branch-1-test",
            "description": "Branch 1 JSON content with changes",
            "config": {
              "enabled": false,
              "mode": "production",
              "newField": "branch1-specific"
            }
          }
'@ | Set-Content -Path $TEST_JSON

          @'
          # Branch 1 Documentation

          This is the branch 1 version of the documentation.

          ## Section 1
          Branch 1 has completely different content here.

          ## Section 2
          Branch 1 removed the original section 2.

          ## Section 3
          New section added only in branch 1.
'@ | Set-Content -Path $TEST_MD

          @'
          export function branch1Function(): string {
            console.log('Branch 1 version');
            return 'branch1';
          }

          export class Branch1Class {
            private value: string;

            constructor() {
              this.value = 'branch1';
            }

            getValue(): string {
              return this.value;
            }
            
            branch1Method(): void {
              console.log('Branch 1 specific method');
            }
          }
'@ | Set-Content -Path $TEST_TS

          @'
          # Configuration file - Branch 1 version
          application:
            name: branch1-app
            version: 1.1.0
            
          settings:
            debug: true
            timeout: 60
            branch1_setting: enabled
            
          database:
            host: branch1.db.com
            port: 3306
'@ | Set-Content -Path $TEST_CONFIG_YML

          @'
          // Critical file - Branch 1 version
          export class CriticalService {
            private apiKey: string;
            private endpoint: string;

            constructor() {
              this.apiKey = 'branch1-key-xyz';
              this.endpoint = 'https://api.branch1.com';
            }

            async performCriticalOperation(): Promise<void> {
              // Branch 1 implementation
              console.log('Branch 1 critical operation');
              await this.validateBranch1();
            }
            
            private async validateBranch1(): Promise<void> {
              // Branch 1 specific validation
            }
          }
'@ | Set-Content -Path $TEST_CRITICAL_TS

          @'
          This is branch 1 version of the text file.
          No resolution rule is defined for this file.

          Branch 1 content:
          - Feature A
          - Feature B
          - Feature C

          Branch 1 end.
'@ | Set-Content -Path $TEST_TXT

          @'
          <?xml version="1.0" encoding="UTF-8"?>
          <configuration>
            <settings>
              <property name="version">1.1.0</property>
              <property name="mode">branch1</property>
              <property name="branch1">true</property>
            </settings>
            <data>
              <item id="1">Branch 1 Item 1</item>
              <item id="2">Branch 1 Item 2</item>
              <item id="3">Branch 1 New Item</item>
            </data>
          </configuration>
'@ | Set-Content -Path $TEST_XML

          # Create different binary files for branch 1
          # PNG file (2x2 pixels)
          $pngBytes = [byte[]]@(
            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
            0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
            0x08, 0x02, 0x00, 0x00, 0x00, 0xFD, 0xD4, 0x9A, 0x73,
            0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 0x63, 0xF8, 0x0F, 0x00, 0x00, 0x01, 0x01, 0x00, 0x05,
            0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
          )
          [System.IO.File]::WriteAllBytes($TEST_PNG, $pngBytes)

          # PDF file
          $pdfContent = @"
%PDF-1.4
%Branch1
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /Resources << >> /MediaBox [0 0 612 792] >>
endobj
xref
0 4
0000000000 65535 f
0000000009 00000 n
0000000058 00000 n
0000000115 00000 n
trailer
<< /Size 4 /Root 1 0 R >>
startxref
203
%%EOF
"@
          $pdfContent | Set-Content -Path $TEST_PDF -NoNewline

          # ZIP file
          "Branch 1 content for ZIP" | Set-Content -Path $TEST_TEMP
          Push-Location $TEST_DIR
          Compress-Archive -Path (Split-Path $TEST_TEMP -Leaf) -DestinationPath (Split-Path $TEST_ZIP -Leaf) -Force
          Remove-Item (Split-Path $TEST_TEMP -Leaf)
          Pop-Location

          git add "$TEST_DIR/"
          git commit -m "Branch 1 changes"

          # Create branch 2 with different changes
          git checkout test-base-${{ github.run_id }}
          git checkout -b test-branch-2-${{ github.run_id }}

          # Modify files differently in branch 2
          @'
          {
            "version": "1.2.0",
            "name": "branch-2-test",
            "description": "Branch 2 JSON with different changes",
            "config": {
              "enabled": true,
              "mode": "development",
              "differentField": "branch2-specific"
            }
          }
'@ | Set-Content -Path $TEST_JSON

          @'
          # Branch 2 Documentation

          This is the branch 2 version of the documentation.

          ## Section 1
          Branch 2 has its own content for section 1.

          ## Section 2
          Branch 2 kept section 2 but changed it.

          ### Subsection 2.1
          Branch 2 modified subsection.

          ## Section 4
          Branch 2 added section 4 instead of 3.
'@ | Set-Content -Path $TEST_MD

          @'
          export function branch2Function(): string {
            console.log('Branch 2 version');
            return 'branch2';
          }

          export class Branch2Class {
            private value: string;

            constructor() {
              this.value = 'branch2';
            }

            getValue(): string {
              return this.value;
            }
            
            branch2Method(): void {
              console.log('Branch 2 specific method');
            }
          }
'@ | Set-Content -Path $TEST_TS

          @'
          # Configuration file - Branch 2 version
          application:
            name: branch2-app
            version: 1.2.0
            
          settings:
            debug: false
            timeout: 90
            branch2_setting: active
            
          database:
            host: branch2.db.com
            port: 5432
            replica: true
'@ | Set-Content -Path $TEST_CONFIG_YML

          @'
          // Critical file - Branch 2 version
          export class CriticalService {
            private apiKey: string;
            private endpoint: string;
            private region: string;

            constructor() {
              this.apiKey = 'branch2-key-abc';
              this.endpoint = 'https://api.branch2.com';
              this.region = 'us-west';
            }

            async performCriticalOperation(): Promise<void> {
              // Branch 2 implementation
              console.log('Branch 2 critical operation');
              await this.validateBranch2();
            }
            
            private async validateBranch2(): Promise<void> {
              // Branch 2 specific validation
            }
          }
'@ | Set-Content -Path $TEST_CRITICAL_TS

          @'
          This is branch 2 version of the text file.
          No resolution rule is defined for this file.

          Branch 2 content:
          - Feature X
          - Feature Y
          - Feature Z

          Branch 2 end.
'@ | Set-Content -Path $TEST_TXT

          @'
          <?xml version="1.0" encoding="UTF-8"?>
          <configuration>
            <settings>
              <property name="version">1.2.0</property>
              <property name="mode">branch2</property>
              <property name="branch2">true</property>
            </settings>
            <data>
              <item id="1">Branch 2 Item 1</item>
              <item id="2">Branch 2 Item 2</item>
              <item id="4">Branch 2 Different Item</item>
            </data>
          </configuration>
'@ | Set-Content -Path $TEST_XML

          # Create different binary files for branch 2
          # PNG file (3x3 pixels)
          $pngBytes = [byte[]]@(
            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
            0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
            0x08, 0x02, 0x00, 0x00, 0x00, 0xD9, 0x4A, 0x22, 0xE8,
            0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9C, 0x63, 0xF8, 0x0F, 0x00, 0x00, 0x01, 0x01, 0x00, 0x05,
            0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
          )
          [System.IO.File]::WriteAllBytes($TEST_PNG, $pngBytes)

          # PDF file
          $pdfContent = @"
%PDF-1.4
%Branch2
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 2 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /Resources << >> /MediaBox [0 0 612 792] >>
endobj
xref
0 4
0000000000 65535 f
0000000009 00000 n
0000000058 00000 n
0000000115 00000 n
trailer
<< /Size 4 /Root 1 0 R >>
startxref
203
%%EOF
"@
          $pdfContent | Set-Content -Path $TEST_PDF -NoNewline

          # ZIP file
          "Branch 2 content for ZIP" | Set-Content -Path $TEST_TEMP
          Push-Location $TEST_DIR
          Compress-Archive -Path (Split-Path $TEST_TEMP -Leaf) -DestinationPath (Split-Path $TEST_ZIP -Leaf) -Force
          Remove-Item (Split-Path $TEST_TEMP -Leaf)
          Pop-Location

          git add "$TEST_DIR/"
          git commit -m "Branch 2 changes"

          # Attempt to merge branch 1 into branch 2 to create conflicts
          Write-Output "::notice::Attempting to merge branch-1 into branch-2..."
          git merge test-branch-1-${{ github.run_id }} --no-ff --no-commit 2>$null

          # Check conflict status
          Write-Output "::group::Git status after merge attempt"
          git status
          Write-Output "::endgroup::"

          Write-Output "::group::Conflicted files"
          $conflicted = git status --porcelain | Where-Object { $_ -match "^UU" }
          if ($conflicted) {
            $conflicted
          } else {
            Write-Output "No conflicts found"
          }
          Write-Output "::endgroup::"

          # Save conflict state
          if (git status --porcelain | Where-Object { $_ -match "^UU" }) {
            "has_conflicts=true" | Add-Content -Path $env:GITHUB_OUTPUT
            Write-Output "::notice::Conflicts detected. Ready to test conflict resolver."
          } else {
            "has_conflicts=false" | Add-Content -Path $env:GITHUB_OUTPUT
            Write-Output "::warning::No conflicts detected."
          }

      - name: Show conflict details
        if: steps.create-conflicts.outputs.has_conflicts == 'true'
        shell: pwsh
        run: |
          Write-Output "::group::List of conflicted files"
          git diff --name-only --diff-filter=U
          Write-Output "::endgroup::"

          $TEST_DIR = "test-conflict-files"
          $extensions = @("json", "md", "ts", "yml", "txt", "xml")
          
          foreach ($ext in $extensions) {
            $files = Get-ChildItem -Path "$TEST_DIR/*.$ext" -ErrorAction SilentlyContinue
            foreach ($file in $files) {
              $conflictCheck = git diff --check $file.FullName 2>$null | Select-String "conflict"
              if ($conflictCheck) {
                Write-Output "::group::Conflict in $($file.Name)"
                Get-Content $file.FullName | Select-Object -First 50
                Write-Output "::endgroup::"
              }
            }
          }

      - name: Test Local Action
        id: test-action
        uses: ./
        with:
          config-path: '.github/conflict-resolver-sample.yml'

      - name: Print Output
        id: output
        shell: pwsh
        env:
          RESOLVED_FILES: ${{ steps.test-action.outputs.resolved-files }}
          UNRESOLVED_FILES: ${{ steps.test-action.outputs.unresolved-files }}
        run: |
          Write-Output "::notice::Resolved files: $env:RESOLVED_FILES"
          Write-Output "::notice::Unresolved files: $env:UNRESOLVED_FILES"

          # Define test file paths for verification
          $TEST_DIR = "test-conflict-files"
          $TEST_JSON = "$TEST_DIR/test.json"
          $TEST_MD = "$TEST_DIR/test.md"
          $TEST_TS = "$TEST_DIR/test.ts"
          $TEST_CONFIG_YML = "$TEST_DIR/test.config.yml"
          $TEST_CRITICAL_TS = "$TEST_DIR/critical.ts"
          $TEST_TXT = "$TEST_DIR/undefined-rule.txt"
          $TEST_XML = "$TEST_DIR/special-case.xml"
          $TEST_PNG = "$TEST_DIR/test.png"
          $TEST_PDF = "$TEST_DIR/test.pdf"
          $TEST_ZIP = "$TEST_DIR/test.zip"

          # Verify expected outcomes
          Write-Output "::group::Verification Results"

          # Check resolved files
          if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_JSON)) {
            Write-Output "✅ test.json resolved (theirs strategy)"
          } else {
            Write-Output "❌ test.json should have been resolved"
          }

          if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_MD)) {
            Write-Output "✅ test.md resolved (ours strategy)"
          } else {
            Write-Output "❌ test.md should have been resolved"
          }

          if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_TS)) {
            Write-Output "✅ test.ts resolved (theirs strategy)"
          } else {
            Write-Output "❌ test.ts should have been resolved"
          }

          # Check binary files
          if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_PNG)) {
            Write-Output "✅ test.png resolved (theirs strategy)"
          } else {
            Write-Output "❌ test.png should have been resolved"
          }

          if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_PDF)) {
            Write-Output "✅ test.pdf resolved (ours strategy)"
          } else {
            Write-Output "❌ test.pdf should have been resolved"
          }

          if ($env:RESOLVED_FILES -match [regex]::Escape($TEST_ZIP)) {
            Write-Output "✅ test.zip resolved (theirs strategy)"
          } else {
            Write-Output "❌ test.zip should have been resolved"
          }

          # Check unresolved files (manual strategy)
          if ($env:UNRESOLVED_FILES -match [regex]::Escape($TEST_CONFIG_YML)) {
            Write-Output "✅ test.config.yml unresolved (manual strategy)"
          } else {
            Write-Output "❌ test.config.yml should remain unresolved"
          }

          if ($env:UNRESOLVED_FILES -match [regex]::Escape($TEST_CRITICAL_TS)) {
            Write-Output "✅ critical.ts unresolved (manual strategy)"
          } else {
            Write-Output "❌ critical.ts should remain unresolved"
          }

          # Check files without rules
          if ($env:UNRESOLVED_FILES -match [regex]::Escape($TEST_TXT)) {
            Write-Output "✅ undefined-rule.txt unresolved (no rule defined)"
          } else {
            Write-Output "❌ undefined-rule.txt should remain unresolved"
          }

          if ($env:UNRESOLVED_FILES -match [regex]::Escape($TEST_XML)) {
            Write-Output "✅ special-case.xml unresolved (no rule defined)"
          } else {
            Write-Output "❌ special-case.xml should remain unresolved"
          }

          Write-Output "::endgroup::"

      - name: Show final file contents
        shell: pwsh
        run: |
          # Define test file paths
          $TEST_DIR = "test-conflict-files"
          $TEST_JSON = "$TEST_DIR/test.json"
          $TEST_MD = "$TEST_DIR/test.md"
          $TEST_CONFIG_YML = "$TEST_DIR/test.config.yml"
          $TEST_CRITICAL_TS = "$TEST_DIR/critical.ts"
          $TEST_TXT = "$TEST_DIR/undefined-rule.txt"
          $TEST_XML = "$TEST_DIR/special-case.xml"

          Write-Output "::group::Final resolved file contents (samples)"

          Write-Output "--- test.json (should have branch-1 content - theirs) ---"
          Get-Content $TEST_JSON | Select-Object -First 10

          Write-Output ""
          Write-Output "--- test.md (should have branch-2 content - ours) ---"
          Get-Content $TEST_MD | Select-Object -First 10

          Write-Output "::endgroup::"

          Write-Output "::group::Unresolved files with conflict markers"

          $unresolved = @($TEST_CONFIG_YML, $TEST_CRITICAL_TS, $TEST_TXT, $TEST_XML)
          foreach ($file in $unresolved) {
            if (Test-Path $file) {
              Write-Output "--- $file ---"
              $markers = Get-Content $file | Where-Object { $_ -match "^(<<<<<<<|=======|>>>>>>>)" }
              if ($markers) {
                $markers
              } else {
                Write-Output "No conflict markers found (might be an error)"
              }
              Write-Output ""
            }
          }

          Write-Output "::endgroup::"
